## 将非坐标数据传入顶点着色器

在前几个例子中都是传递的坐标数据：
1. 创建缓冲区
2. 将缓冲区对象绑定到target上
3. 将顶点数据写入缓冲区
4. 将缓冲区对象分配给对应的attribute变量
5. 开启attribute变量

gl_Position内置变量控制了顶点着色器的大小，这里我们将展示如何传递非坐标数据：(mutilAttributeSize)[./mutilAttributeSize.html]。

原理和方法与之前传递坐标数据一样。

## 如何将多种类型的数据放在一个缓冲区内

对于不同类型的变量，我们可以放在不同缓冲区内以便区分，但是我们也可以将不同类型的变量数据放在同一个缓冲区内，然后有差别的读取缓冲区内的数据，然后赋值给对应的变量。详见p136

使用vertexAttribPointer可以有差别的读取缓冲区内的数据，然后赋值给对应的变量：[multiAttributeSize_interleaved](./multiAttributeSize_interleaved.html)。

## 修改顶点的颜色

影响颜色的gl_FragColor变量在片元着色器中。在第二节我们也进行过多元色顶点的绘制[colorPoints](./2.webGL入门/colorPoints.html)。

我们现在是将数据传入到顶点着色器中的，所以需要使用到varying变量，来将顶点着色器的的变量传递到片元着色器之中，p141。

**使用varying变量从顶点着色器向片元着色器传递变量时需要在顶点着色器和片元着色器中声明两个同名的变量。**

```js
const vertexShader = `
  varying vec4 v_Color;
`

const fragmentShader = `
  varying vec4 v_Color;
`
```

## 片元着色器彩色三角

绘制的大致过程：p146
0. 输入顶点坐标
1. 图形装配过程：将孤立的顶点坐标装配成几何图形，被装配出的图形又被称为**图元**
2. 光栅化过程：将装配好的几何图形转化为片元，**片元的数量就是图形在屏幕中最终所覆盖的像素数**
3. 执行片元着色器。对于每个片元，片元着色器会计算出改片元的颜色，并将颜色写入到缓冲区

## varying变量的内插过程

顶点着色器的变量在传递到片元着色器中时会经历**内插过程**。内插过程是指所有片元的颜色都会被恰当的计算出来，比如：定义线段两个端点的颜色分别为红色(1.0, 0.0, 0.0)，蓝色(0.0, 0.0, 1.0)，那么两个端点其他点的颜色也会被计算出来。

## 纹理

将一张图像映射到一个几何图形的表面，那么该图像就叫做**纹理**或者**纹理图像**。**纹理映射**就是根据纹理图像，为光栅化之后的片元涂上合适的颜色。组成纹理图案的像素又被称之为**纹素**。

纹理映射的步骤：
1. 准备好映射到集合图像上的纹理图像
2. 为几何图形配置纹理映射的方式
3. 加载纹理图像，对其进行一些配置，以便在webGL中使用
4. 在片元着色器中将相应的纹素从纹理中抽取出来，并将纹素的颜色赋值给片元

## 纹理坐标

为了与x坐标和y坐标区分开来，webGL使用s和t命名纹理坐标，s轴水平向右：0.0 ~ 1.0；t轴垂直向上：0.0 ~ 1.0。纹理坐标和图像自身的尺寸无关，不管图像是多大尺寸其左上角的纹理尺寸都是(1.0, 1.0)。

知道纹理坐标后，我们就需要将纹理坐标和webGL的坐标进行映射，这就叫做纹理映射，p156。

gl.createTexture()：创建纹理对象

sampler2D：取样器变量，从纹理图像获取纹素的过程，即输入纹理坐标返回颜色值，p160。

### 设置纹理步骤

1. 设置纹理坐标，使用attribute变量传值，p160
2. 配置和加载纹理，gl.createTexture，p161
3. 反转图像Y轴,
3. 激活纹理单元，gl.activeTexture，p165
5. 绑定纹理对象，告诉webGL使用的哪一种纹理，gl.bindTexture
6. 配置纹理参数，设置纹理图映射到图形上的具体方法，gl.texParamteri，p168
7. 将纹理图像分配给纹理对象，gl.texImage2D，调用此方法后Image对象中的图像就从JavaScript传入到了webGL中并存储到纹理对象之中，p171
8. 将纹理单元传递给片元着色器，使用sampler2D数据类型来表示片元着色器中的纹理，gl.uniform1i，p173
9. 从顶点着色器向片元着色器传输纹理坐标，纹理坐标是通过JavaScript传递给顶点着色器的，
10. 在片元着色器中获取纹理像素颜色，gl_FragColor = texture2D(u_Sampler, v_TexCoord)，内置函数texture2D可以抽取纹素的颜色

在webGL中支持同时设置两张不同格式类型的纹理图像，p178。
