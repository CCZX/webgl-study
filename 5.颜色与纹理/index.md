## 将非坐标数据传入顶点着色器

在前几个例子中都是传递的坐标数据：
1. 创建缓冲区
2. 将缓冲区对象绑定到target上
3. 将顶点数据写入缓冲区
4. 将缓冲区对象分配给对应的attribute变量
5. 开启attribute变量

gl_Position内置变量控制了顶点着色器的大小，这里我们将展示如何传递非坐标数据：(mutilAttributeSize)[./mutilAttributeSize.html]。

原理和方法与之前传递坐标数据一样。

## 如何将多种类型的数据放在一个缓冲区内

对于不同类型的变量，我们可以放在不同缓冲区内以便区分，然后传递到着色器中去，存储在缓冲区中的数据将按照顺序传递给着色器中的变量。但是我们也可以将不同类型的变量数据放在同一个缓冲区内，然后有差别的读取缓冲区内的数据，然后赋值给对应的变量，详见p136。使用vertexAttribPointer可以有差别（**步进和偏移**）的读取缓冲区内的数据，然后赋值给对应的变量：[multiAttributeSize_interleaved](./multiAttributeSize_interleaved.html)。

使用vertexAttribPointer将几种**逐顶点**数据存储在一个缓冲区对象中。

## 修改顶点的颜色

影响颜色的gl_FragColor变量在片元着色器中。在第二节我们也进行过多元色顶点的绘制[colorPoints](./2.webGL入门/colorPoints.html)，是通过多次调用drawArrays的方式。我们现在是将数据传入到顶点着色器中的，所以需要使用到varying变量，来将顶点着色器的的变量传递到片元着色器之中，p141，发生在顶点着色器到片元着色器之间的从图形到片元之间的转换叫做**图元光栅化**。

**使用varying变量从顶点着色器向片元着色器传递变量时需要在顶点着色器和片元着色器中声明两个同名的变量。**

```js
const vertexShader = `
  varying vec4 v_Color;
`

const fragmentShader = `
  varying vec4 v_Color;
`
```

## 几何图形的装配与光栅化

绘制的大致过程：p146
0. 输入顶点坐标
1. **图形装配过程**：将孤立的顶点坐标装配成几何图形，被装配出的图形又被称为**图元**，几何图形的类别由drawArrays来决定。
2. **光栅化过程**：将装配好的几何图形转化为片元，**片元的数量就是图形在屏幕中最终所覆盖的像素数**
3. 执行片元着色器。对于每个片元，片元着色器会计算出改片元的颜色，并将颜色写入到缓冲区

发生在顶点着色器到片元着色器之间的从图形到片元之间的转换叫做**图元光栅化**。在光栅化结束后程序就开始逐片调用片元着色器，每个片元着色器计算出对应的颜色值后会将颜色写入缓冲区，然后最后展示出来。**光栅化的过程中生成的片元都是带有坐标信息的**，通过**gl_FragCoord**内置变量可以访问片元的坐标信息。

vec4 gl_FragCoord，第一个和第二个分量表示该片元在canvas坐标系中的坐标值。使用gl.drawingBufferWidth和gl.drawingBufferHeight可以获取到颜色缓冲区的宽高。

## varying变量的内插过程

顶点着色器的变量在传递到片元着色器中时会经历**内插过程**。内插过程是指所有片元的颜色都会被恰当的计算出来，比如：定义线段两个端点的颜色分别为红色(1.0, 0.0, 0.0)，蓝色(0.0, 0.0, 1.0)，那么两个端点其他点的颜色也会被计算出来。顶点着色器中的颜色变量在传递给片元着色器之前也经历了内插的过程，**顶点着色器和片元着色器之间的内插的过程发生在光栅化阶段**

## 纹理

将一张图像映射到一个几何图形的表面，那么该图像就叫做**纹理**或者**纹理图像**。**纹理映射**就是根据纹理图像，为光栅化之后的片元涂上合适的颜色。组成纹理图案的像素又被称之为**纹素**。

纹理映射的步骤：
1. 准备好映射到集合图像上的纹理图像
2. 为几何图形配置纹理映射的方式：确定片元的颜色取决于纹理的那个或者那几个像素，即映射问题
3. 加载纹理图像，对其进行一些配置，以便在webGL中使用
4. 在片元着色器中将相应的纹素从纹理中抽取出来，并将纹素的颜色赋值给片元

## 纹理坐标

为了与x坐标和y坐标区分开来，webGL使用s和t命名纹理坐标（另一种习惯性命名是u/v坐标），s轴水平向右：0.0 ~ 1.0；t轴垂直向上：0.0 ~ 1.0。纹理坐标和图像自身的尺寸无关，不管图像是多大尺寸其左上角的纹理尺寸都是(1.0, 1.0)。

知道纹理坐标后，我们就需要将纹理坐标和webGL的坐标进行映射，这就叫做纹理映射，p156。

gl.createTexture()：创建纹理对象

sampler2D：取样器变量，从纹理图像获取纹素的过程，即输入纹理坐标返回颜色值，p160。

### 设置纹理步骤

1. 设置纹理坐标，使用attribute变量传值，p160
2. 配置和加载纹理，gl.createTexture，p161
3. 反转图像Y轴，纹理坐标的t方向和PNG等图片的Y轴方向是相反的
3. 激活纹理单元，gl.activeTexture，每个纹理单元有一单元编号来管理纹理图像，系统所支持的纹理单元个数取决于硬件和浏览器的webGL环境，但是最少支持8个纹理单元，gl.TEXTURE0、gl.TEXTURE1...依次表示一个纹理单元，p165
5. 绑定纹理对象，告诉webGL使用的哪一种纹理，gl.bindTexture，如果有已经激活的纹理单元那么纹理对象也会被绑定到该纹理单元上
6. 配置纹理参数和纹理参数的值，设置纹理图映射到图形上的具体方法，gl.texParamteri，p168
7. 将纹理图像分配给纹理对象，gl.texImage2D，调用此方法后Image对象中的图像就从JavaScript传入到了webGL中并存储到纹理对象之中，p171
8. 将纹理单元传递给片元着色器，使用sampler2D数据类型来表示片元着色器中的纹理，gl.uniform1i，p173
9. 从顶点着色器向片元着色器传输纹理坐标，纹理坐标是通过JavaScript传递给顶点着色器的，
10. 在片元着色器中获取纹理像素颜色，gl_FragColor = texture2D(u_Sampler, v_TexCoord)，内置函数texture2D可以抽取纹素的颜色

在webGL中支持同时设置两张不同格式类型的纹理图像，p178。
